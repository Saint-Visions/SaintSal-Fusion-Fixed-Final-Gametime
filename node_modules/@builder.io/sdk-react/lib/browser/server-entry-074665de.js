const b = "react", v = "[Builder.io]: ", f = {
  log: (...t) => console.log(v, ...t),
  error: (...t) => console.error(v, ...t),
  warn: (...t) => console.warn(v, ...t),
  debug: (...t) => console.debug(v, ...t)
};
function c() {
  return typeof window != "undefined" && typeof document != "undefined";
}
const at = (t) => {
  const e = {};
  return t.forEach((n, r) => {
    e[r] = n;
  }), e;
}, M = (t) => t instanceof URLSearchParams ? at(t) : t, W = (t) => typeof t == "string" ? t : t instanceof URLSearchParams ? t.toString() : new URLSearchParams(t).toString();
function ct() {
  return c() && window.self !== window.top;
}
function ut(t) {
  return ct() && // accessing window.location.search is safe here because `isIframe()` is only `true` if we're in a browser.
  W(t || window.location.search).indexOf("builder.frameEditing=") !== -1;
}
const lt = () => {
  if (c()) {
    const t = new URL(location.href);
    return t.pathname === "" && (t.pathname = "/"), t;
  } else
    return console.warn("Cannot get location for tracking in non-browser environment"), null;
}, dt = () => typeof navigator == "object" && navigator.userAgent || "", ft = () => {
  const t = dt(), e = {
    Android() {
      return t.match(/Android/i);
    },
    BlackBerry() {
      return t.match(/BlackBerry/i);
    },
    iOS() {
      return t.match(/iPhone|iPod/i);
    },
    Opera() {
      return t.match(/Opera Mini/i);
    },
    Windows() {
      return t.match(/IEMobile/i) || t.match(/WPDesktop/i);
    },
    any() {
      return e.Android() || e.BlackBerry() || e.iOS() || e.Opera() || e.Windows() || b === "reactNative";
    }
  }, n = t.match(/Tablet|iPad/i), r = lt();
  return {
    urlPath: r == null ? void 0 : r.pathname,
    host: (r == null ? void 0 : r.host) || (r == null ? void 0 : r.hostname),
    device: n ? "tablet" : e.any() ? "mobile" : "desktop"
  };
}, y = (t) => t != null;
function ee(t) {
  const e = t || (c() ? window.location.search : void 0);
  return e ? W(e).indexOf("builder.preview=") !== -1 : !1;
}
const ne = (t) => ({
  type: "builder.registerComponent",
  data: j(t)
}), ht = (t) => {
  const e = t.toString().trim(), n = /^[a-zA-Z0-9_]+\s*=>/i.test(e);
  return `return (${!e.startsWith("function") && !e.startsWith("async") && !e.startsWith("(") && !n ? "function " : ""}${e}).apply(this, arguments)`;
};
function j(t) {
  return JSON.parse(JSON.stringify(t, (e, n) => typeof n == "function" ? ht(n) : n));
}
const _ = {};
function re(t, e) {
  t === "plugin" && (e = j(e));
  let n = _[t];
  if (n || (n = _[t] = []), n.push(e), c()) {
    const r = {
      type: "builder.register",
      data: {
        type: t,
        info: e
      }
    };
    try {
      parent.postMessage(r, "*"), parent !== window && window.postMessage(r, "*");
    } catch (s) {
      console.debug("Could not postmessage", s);
    }
  }
}
function se(t) {
  var e;
  if (c()) {
    const n = JSON.parse(JSON.stringify(t));
    t.action && (n.action = t.action.toString()), (e = window.parent) == null || e.postMessage({
      type: "builder.registerAction",
      data: n
    }, "*");
  }
}
const L = {};
function oe(t) {
  if (c()) {
    Object.assign(L, t);
    const e = {
      type: "builder.settingsChange",
      data: L
    };
    parent.postMessage(e, "*");
  }
}
const N = "builder.", gt = "options.", $ = (t) => {
  if (!t)
    return {};
  const e = M(t), n = {};
  return Object.keys(e).forEach((r) => {
    if (r.startsWith(N)) {
      const s = r.replace(N, "").replace(gt, "");
      n[s] = e[r];
    }
  }), n;
}, pt = () => {
  if (!c())
    return {};
  const t = new URLSearchParams(window.location.search);
  return $(t);
}, G = "4.2.2", J = () => ({
  "X-Builder-SDK": b,
  "X-Builder-SDK-GEN": "2",
  "X-Builder-SDK-Version": G
}), St = (t) => {
  if (t === "localhost" || t === "127.0.0.1")
    return t;
  const e = t.split(".");
  return e.length > 2 ? e.slice(1).join(".") : t;
}, O = ({
  name: t,
  canTrack: e
}) => {
  var n;
  try {
    return e ? (n = document.cookie.split("; ").find((r) => r.startsWith(`${t}=`))) == null ? void 0 : n.split("=")[1] : void 0;
  } catch (r) {
    f.warn("[COOKIE] GET error: ", (r == null ? void 0 : r.message) || r);
    return;
  }
}, z = async (t) => O(t), yt = (t) => t.map(([e, n]) => n ? `${e}=${n}` : e).filter(y).join("; "), bt = [["secure", ""], ["SameSite", "None"]], mt = ({
  name: t,
  value: e,
  expires: n
}) => {
  const s = (c() ? location.protocol === "https:" : !0) ? bt : [[]], o = n ? [["expires", n.toUTCString()]] : [[]], i = [[t, e], ...o, ["path", "/"], ["domain", St(window.location.hostname)], ...s];
  return yt(i);
}, T = async ({
  name: t,
  value: e,
  expires: n,
  canTrack: r
}) => {
  try {
    if (!r)
      return;
    const s = mt({
      name: t,
      value: e,
      expires: n
    });
    document.cookie = s;
  } catch (s) {
    f.warn("[COOKIE] SET error: ", (s == null ? void 0 : s.message) || s);
  }
};
function wt() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(t) {
    const e = Math.random() * 16 | 0;
    return (t == "x" ? e : e & 3 | 8).toString(16);
  });
}
function X() {
  return wt().replace(/-/g, "");
}
const H = "builderSessionId", Et = async ({
  canTrack: t
}) => {
  if (!t)
    return;
  const e = await z({
    name: H,
    canTrack: t
  });
  if (y(e))
    return e;
  {
    const n = It();
    return vt({
      id: n,
      canTrack: t
    }), n;
  }
}, It = () => X(), vt = ({
  id: t,
  canTrack: e
}) => T({
  name: H,
  value: t,
  canTrack: e
}), Q = () => c() && typeof localStorage != "undefined" ? localStorage : void 0, At = ({
  key: t,
  canTrack: e
}) => {
  var n;
  try {
    return e ? (n = Q()) == null ? void 0 : n.getItem(t) : void 0;
  } catch (r) {
    console.debug("[LocalStorage] GET error: ", r);
    return;
  }
}, kt = ({
  key: t,
  canTrack: e,
  value: n
}) => {
  var r;
  try {
    e && ((r = Q()) == null || r.setItem(t, n));
  } catch (s) {
    console.debug("[LocalStorage] SET error: ", s);
  }
}, Y = "builderVisitorId", Ut = ({
  canTrack: t
}) => {
  if (!t)
    return;
  const e = At({
    key: Y,
    canTrack: t
  });
  if (y(e))
    return e;
  {
    const n = Ot();
    return Tt({
      id: n,
      canTrack: t
    }), n;
  }
}, Ot = () => X(), Tt = ({
  id: t,
  canTrack: e
}) => kt({
  key: Y,
  value: t,
  canTrack: e
});
function Pt(t) {
  var e;
  typeof process != "undefined" && ((e = process.env) != null && e.DEBUG) && String(process.env.DEBUG) == "true" && f.log(t);
}
const Rt = async ({
  canTrack: t
}) => {
  if (!t)
    return {
      visitorId: void 0,
      sessionId: void 0
    };
  const e = await Et({
    canTrack: t
  }), n = Ut({
    canTrack: t
  });
  return {
    sessionId: e,
    visitorId: n
  };
}, Ct = async ({
  type: t,
  canTrack: e,
  apiKey: n,
  metadata: r,
  ...s
}) => ({
  type: t,
  data: {
    ...s,
    metadata: {
      url: location.href,
      ...r
    },
    ...await Rt({
      canTrack: e
    }),
    userAttributes: ft(),
    ownerId: n
  }
});
async function Bt({
  apiHost: t,
  ...e
}) {
  if (!e.apiKey) {
    f.error("Missing API key for track call. Please provide your API key.");
    return;
  }
  if (!e.canTrack || ut() || !(c() || b === "reactNative"))
    return;
  const r = `${t || "https://cdn.builder.io"}/api/v1/track`;
  return Pt(r), fetch(r, {
    method: "POST",
    body: JSON.stringify({
      events: [await Ct(e)]
    }),
    headers: {
      "content-type": "application/json",
      ...J()
    },
    mode: "cors"
  }).catch((s) => {
    console.error("Failed to track: ", s);
  });
}
const ie = (t) => Bt({
  ...t,
  canTrack: !0
}), xt = ["*.beta.builder.io", "beta.builder.io", "builder.io", "localhost", "qa.builder.io"];
function Z(t, e) {
  if (!e.origin.startsWith("http") && !e.origin.startsWith("https"))
    return !1;
  const n = new URL(e.origin), r = n.hostname;
  return (t || xt).findIndex((s) => s.startsWith("*.") ? r.endsWith(s.slice(1)) : s === r) > -1;
}
let V = !1;
const _t = (t) => {
  var e, n;
  V || (V = !0, c() && ((e = window.parent) == null || e.postMessage({
    type: "builder.sdkInfo",
    data: {
      target: b,
      version: G,
      supportsPatchUpdates: !1,
      // Supports builder-model="..." attribute which is needed to
      // scope our '+ add block' button styling
      supportsAddBlockScoping: !0,
      supportsCustomBreakpoints: !0,
      modelName: t.modelName,
      apiKey: t.apiKey,
      supportsXSmallBreakpoint: !0,
      blockLevelPersonalization: !0
    }
  }, "*"), (n = window.parent) == null || n.postMessage({
    type: "builder.updateContent",
    data: {
      options: t
    }
  }, "*"), window.addEventListener("message", (r) => {
    var o, i;
    if (!Z(t.trustedHosts, r))
      return;
    const {
      data: s
    } = r;
    if (s != null && s.type)
      switch (s.type) {
        case "builder.evaluate": {
          const u = s.data.text, m = s.data.arguments || [], p = s.data.id, w = new Function(u);
          let l, h = null;
          try {
            l = w.apply(null, m);
          } catch (g) {
            h = g;
          }
          h ? (o = window.parent) == null || o.postMessage({
            type: "builder.evaluateError",
            data: {
              id: p,
              error: h.message
            }
          }, "*") : l && typeof l.then == "function" ? l.then((g) => {
            var E;
            (E = window.parent) == null || E.postMessage({
              type: "builder.evaluateResult",
              data: {
                id: p,
                result: g
              }
            }, "*");
          }).catch(console.error) : (i = window.parent) == null || i.postMessage({
            type: "builder.evaluateResult",
            data: {
              result: l,
              id: p
            }
          }, "*");
          break;
        }
      }
  })));
}, Lt = ({
  model: t,
  trustedHosts: e,
  callbacks: n
}) => (r) => {
  if (!Z(e, r))
    return;
  const {
    data: s
  } = r;
  if (s)
    switch (s.type) {
      case "builder.configureSdk": {
        n.configureSdk(s.data);
        break;
      }
      case "builder.triggerAnimation": {
        n.animation(s.data);
        break;
      }
      case "builder.resetState": {
        const o = s.data, i = o.model, u = o == null ? void 0 : o.state;
        i === t && u && n.stateUpdate(u);
        break;
      }
      case "builder.contentUpdate": {
        const o = s.data, i = o.key || o.alias || o.entry || o.modelName, u = o.data;
        i === t && n.contentUpdate(u);
        break;
      }
    }
}, ae = ({
  model: t,
  apiKey: e,
  callback: n,
  trustedHosts: r
}) => {
  if (!c)
    return f.warn("`subscribeToEditor` only works in the browser. It currently seems to be running on the server."), () => {
    };
  _t({
    modelName: t,
    apiKey: e
  });
  const s = Lt({
    callbacks: {
      contentUpdate: n,
      animation: () => {
      },
      configureSdk: () => {
      },
      stateUpdate: () => {
      }
    },
    model: t,
    trustedHosts: r
  });
  return window.addEventListener("message", s), () => {
    window.removeEventListener("message", s);
  };
}, Nt = "builder.tests", P = (t) => `${Nt}.${t}`, Vt = ({
  contentId: t
}) => z({
  name: P(t),
  canTrack: !0
}), Dt = ({
  contentId: t
}) => O({
  name: P(t),
  canTrack: !0
}), Ft = ({
  contentId: t,
  value: e
}) => T({
  name: P(t),
  value: e,
  canTrack: !0
}), q = (t) => y(t.id) && y(t.variations) && Object.keys(t.variations).length > 0, Kt = ({
  id: t,
  variations: e
}) => {
  var s;
  let n = 0;
  const r = Math.random();
  for (const o in e) {
    const i = (s = e[o]) == null ? void 0 : s.testRatio;
    if (n += i, r < n)
      return o;
  }
  return t;
}, tt = (t) => {
  const e = Kt(t);
  return Ft({
    contentId: t.id,
    value: e
  }).catch((n) => {
    f.error("could not store A/B test variation: ", n);
  }), e;
}, et = ({
  item: t,
  testGroupId: e
}) => {
  const n = t.variations[e];
  return e === t.id || // handle edge-case where `testGroupId` points to non-existing variation
  !n ? {
    testVariationId: t.id,
    testVariationName: "Default"
  } : {
    data: n.data,
    testVariationId: n.id,
    testVariationName: n.name || (n.id === t.id ? "Default" : "")
  };
}, ce = ({
  item: t,
  canTrack: e
}) => {
  if (!e)
    return t;
  if (!t)
    return;
  if (!q(t))
    return t;
  const n = Dt({
    contentId: t.id
  }) || tt({
    variations: t.variations,
    id: t.id
  }), r = et({
    item: t,
    testGroupId: n
  });
  return {
    ...t,
    ...r
  };
}, Mt = async ({
  item: t,
  canTrack: e
}) => {
  if (!e || !q(t))
    return t;
  const r = await Vt({
    contentId: t.id
  }) || tt({
    variations: t.variations,
    id: t.id
  }), s = et({
    item: t,
    testGroupId: r
  });
  return {
    ...t,
    ...s
  };
};
const D = "builder.userAttributes";
function F() {
  let t = !0;
  const e = /* @__PURE__ */ new Set();
  return {
    setUserAttributes(n) {
      if (!c())
        return;
      const r = {
        ...this.getUserAttributes(),
        ...n
      };
      T({
        name: D,
        value: JSON.stringify(r),
        canTrack: t
      }), e.forEach((s) => s(r));
    },
    getUserAttributes() {
      return c() ? JSON.parse(O({
        name: D,
        canTrack: t
      }) || "{}") : {};
    },
    subscribeOnUserAttributesChange(n, {
      fireImmediately: r
    } = {}) {
      return e.add(n), r && n(this.getUserAttributes()), function() {
        e.delete(n);
      };
    },
    setCanTrack(n) {
      t = n;
    }
  };
}
let k;
c() && b === "qwik" ? (window.__BUILDER_USER_ATTRIBUTES_SERVICE__ || (window.__BUILDER_USER_ATTRIBUTES_SERVICE__ = F()), k = window.__BUILDER_USER_ATTRIBUTES_SERVICE__) : k = F();
const nt = k, ue = (t) => {
  nt.setUserAttributes(t);
}, Wt = (t) => {
  const e = y(t) ? t : !0;
  return nt.setCanTrack(e), e;
};
function jt() {
  return typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : globalThis;
}
function $t() {
  const t = jt().fetch;
  if (typeof t == "undefined")
    throw console.warn(`Builder SDK could not find a global fetch function. Make sure you have a polyfill for fetch in your project. 
      For more information, read https://github.com/BuilderIO/this-package-uses-fetch`), new Error("Builder SDK could not find a global `fetch` function");
  return t;
}
const Gt = $t();
function U(t, e = null, n = ".") {
  return Object.keys(t).reduce((r, s) => {
    const o = t[s], i = [e, s].filter(Boolean).join(n);
    return [typeof o == "object", o !== null, !(Array.isArray(o) && o.length === 0)].every(Boolean) ? {
      ...r,
      ...U(o, i, n)
    } : {
      ...r,
      [i]: o
    };
  }, {});
}
function rt(t, e, n = {}) {
  for (const r in t) {
    const s = t[r], o = e ? e + "." + r : r;
    s && typeof s == "object" && !Array.isArray(s) && !Object.keys(s).find((i) => i.startsWith("$")) ? rt(s, o, n) : n[o] = s;
  }
  return n;
}
function Jt(t) {
  const e = {};
  for (const n in t) {
    const r = n.split(".");
    let s = e;
    for (let o = 0; o < r.length; o++) {
      const i = r[o];
      o === r.length - 1 ? s[i] = t[n] : (s[i] = s[i] || {}, s = s[i]);
    }
  }
  return e;
}
const zt = "v3", K = (t) => typeof t == "number" && !isNaN(t) && t >= 0, R = (t) => {
  const {
    limit: e = 30,
    userAttributes: n,
    query: r,
    model: s,
    apiKey: o,
    enrich: i,
    locale: u,
    apiVersion: m = zt,
    fields: p,
    omit: w,
    offset: l,
    cacheSeconds: h,
    staleCacheSeconds: g,
    sort: E,
    includeUnpublished: C,
    apiHost: st
  } = t;
  if (!o)
    throw new Error("Missing API key");
  if (!["v3"].includes(m))
    throw new Error(`Invalid apiVersion: expected 'v3', received '${m}'`);
  const ot = e !== 1, it = st || "https://cdn.builder.io", a = new URL(`${it}/api/${m}/content/${s}`);
  a.searchParams.set("apiKey", o), a.searchParams.set("limit", String(e)), a.searchParams.set("noTraverse", String(ot)), a.searchParams.set("includeRefs", String(!0));
  const A = u || (n == null ? void 0 : n.locale);
  let S = n || {};
  if (A && (a.searchParams.set("locale", A), S = {
    locale: A,
    ...S
  }), i && a.searchParams.set("enrich", String(i)), a.searchParams.set("omit", w != null ? w : "meta.componentsUsed"), p && a.searchParams.set("fields", p), Number.isFinite(l) && l > -1 && a.searchParams.set("offset", String(Math.floor(l))), typeof C == "boolean" && a.searchParams.set("includeUnpublished", String(C)), h && K(h) && a.searchParams.set("cacheSeconds", String(h)), g && K(g) && a.searchParams.set("staleCacheSeconds", String(g)), E) {
    const d = U({
      sort: E
    });
    for (const I in d)
      a.searchParams.set(I, JSON.stringify(d[I]));
  }
  const B = {
    ...pt(),
    ...M(t.options || {})
  };
  S = {
    ...S,
    ...Ht(B)
  };
  const x = U(B);
  for (const d in x)
    a.searchParams.set(d, String(x[d]));
  if (Object.keys(S).length > 0 && a.searchParams.set("userAttributes", JSON.stringify(S)), r) {
    const d = rt({
      query: r
    });
    for (const I in d)
      a.searchParams.set(I, JSON.stringify(d[I]));
  }
  return a;
}, Xt = (t) => {
  const e = {};
  for (const n in t)
    n.startsWith("userAttributes.") && (e[n] = t[n], delete t[n]);
  return e;
}, Ht = (t) => {
  if (c() && t.preview === "BUILDER_STUDIO") {
    t["userAttributes.urlPath"] = window.location.pathname, t["userAttributes.host"] = window.location.host;
    const e = Xt(t), {
      userAttributes: n
    } = Jt(e);
    return n;
  }
  return {};
}, Qt = (t) => "results" in t;
async function Yt(t) {
  const e = await te({
    ...t,
    limit: 1
  });
  return e && e[0] || null;
}
const Zt = async (t) => {
  var i, u;
  const e = R(t), n = (i = t.fetch) != null ? i : Gt, r = {
    ...t.fetchOptions,
    headers: {
      ...(u = t.fetchOptions) == null ? void 0 : u.headers,
      ...J()
    }
  };
  return await (await n(e.href, r)).json();
}, qt = async (t, e, n = R(t)) => {
  const r = Wt(t.canTrack);
  if (n.search.includes("preview="), !r || !(c() || b === "reactNative"))
    return e.results;
  try {
    const s = [];
    for (const o of e.results)
      s.push(await Mt({
        item: o,
        canTrack: r
      }));
    e.results = s;
  } catch (s) {
    f.error("Could not process A/B tests. ", s);
  }
  return e.results;
};
async function te(t) {
  const e = R(t), n = await Zt(t);
  if (!Qt(n))
    throw f.error("Error fetching data. ", {
      url: e,
      content: n,
      options: t
    }), n;
  return qt(t, n);
}
const le = async (t) => {
  var r, s, o;
  const e = t.path || ((r = t.url) == null ? void 0 : r.pathname) || ((s = t.userAttributes) == null ? void 0 : s.urlPath), n = {
    ...t,
    apiKey: t.apiKey,
    model: t.model || "page",
    userAttributes: {
      ...t.userAttributes,
      ...e ? {
        urlPath: e
      } : {}
    },
    options: $(t.searchParams || ((o = t.url) == null ? void 0 : o.searchParams) || t.options)
  };
  return {
    apiKey: n.apiKey,
    model: n.model,
    content: await Yt(n)
  };
};
export {
  b as TARGET,
  qt as _processContentResult,
  Bt as _track,
  y as checkIsDefined,
  Lt as createEditorListener,
  ne as createRegisterComponentMessage,
  le as fetchBuilderProps,
  te as fetchEntries,
  Yt as fetchOneEntry,
  $ as getBuilderSearchParams,
  O as getCookieSync,
  Wt as getDefaultCanTrack,
  ft as getUserAttributes,
  ce as handleABTestingSync,
  c as isBrowser,
  ut as isEditing,
  ee as isPreviewing,
  Pt as logFetch,
  f as logger,
  re as register,
  se as registerAction,
  j as serializeIncludingFunctions,
  ue as setClientUserAttributes,
  oe as setEditorSettings,
  _t as setupBrowserForEditing,
  ae as subscribeToEditor,
  ie as track,
  nt as userAttributesService
};
