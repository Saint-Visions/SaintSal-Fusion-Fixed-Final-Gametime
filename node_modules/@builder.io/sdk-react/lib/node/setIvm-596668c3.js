import { isEditing, isBrowser, getUserAttributes, TARGET, logger, MSG_PREFIX } from "./server-entry-83d3751d.js";
const getFunctionArguments = ({
  builder: e,
  context: t,
  event: s,
  state: n
}) => Object.entries({
  state: n,
  Builder: e,
  // legacy
  builder: e,
  context: t,
  event: s
}), getBuilderGlobals = () => ({
  isEditing: isEditing(),
  isBrowser: isBrowser(),
  isServer: !isBrowser(),
  getUserAttributes: () => getUserAttributes()
}), parseCode = (e, {
  isExpression: t = !0
}) => /* we disable this for cases where we definitely don't want a return */ t && !(e.includes(";") || e.includes(" return ") || e.trim().startsWith("return ")) ? `return (${e});` : e;
function flattenState({
  rootState: e,
  localState: t,
  rootSetState: s
}) {
  return new Proxy(e, {
    get: (n, r) => {
      if (t && r in t)
        return t[r];
      const o = n[r];
      return typeof o == "object" && o !== null ? flattenState({
        rootState: o,
        localState: void 0,
        rootSetState: s ? (i) => {
          n[r] = i, s(n);
        } : void 0
      }) : o;
    },
    set: (n, r, o) => {
      if (t && r in t)
        throw new Error("Writing to local state is not allowed as it is read-only.");
      return n[r] = o, s == null || s(n), !0;
    }
  });
}
const SDK_NAME_FOR_TARGET = (() => {
  switch (TARGET) {
    case "rsc":
      return "react-nextjs";
    case "reactNative":
      return "react-native";
    default:
      return TARGET;
  }
})(), SDK_NAME = `@builder.io/sdk-${SDK_NAME_FOR_TARGET}`, fastClone = (e) => JSON.parse(JSON.stringify(e)), set = (e, t, s) => {
  if (Object(e) !== e)
    return e;
  const n = Array.isArray(t) ? t : t.toString().match(/[^.[\]]+/g);
  return n.slice(0, -1).reduce((r, o, i) => Object(r[o]) === r[o] ? r[o] : r[o] = Math.abs(Number(n[i + 1])) >> 0 === +n[i + 1] ? [] : {}, e)[n[n.length - 1]] = s, e;
}, noop = () => {
};
let safeDynamicRequire = noop;
try {
  safeDynamicRequire = eval("require");
} catch (e) {
}
const getSyncValName = (e) => `bldr_${e}_sync`, BUILDER_SET_STATE_NAME = "BUILDER_SET_STATE", INJECTED_IVM_GLOBAL = "BUILDER_IVM", REF_TO_PROXY_FN = `
var refToProxy = (obj) => {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }
  return new Proxy({}, {
    get(target, key) {
        if (key === 'copySync') {
          return () => obj.copySync();
        }
        const val = obj.getSync(key);
        if (typeof val?.getSync === 'function') {
            return refToProxy(val);
        }
        return val;
    },
    set(target, key, value) {
        const v = typeof value === 'object' ? new ${INJECTED_IVM_GLOBAL}.Reference(value) : value;
        obj.setSync(key, v);
        ${BUILDER_SET_STATE_NAME}(key, value)
    },
    deleteProperty(target, key) {
        obj.deleteSync(key);
    }
  })
}
`, processCode = ({
  code: e,
  args: t
}) => {
  const s = t.map(([n]) => `var ${n} = refToProxy(${getSyncValName(n)}); `).join("");
  return `
${REF_TO_PROXY_FN}
${s}
function theFunction() {
  ${e}
}

const output = theFunction()

if (typeof output === 'object' && output !== null) {
  return JSON.stringify(output.copySync ? output.copySync() : output);
} else {
  return output;
}
`;
};
let IVM_INSTANCE = null, IVM_CONTEXT = null;
const setIvm = (e, t = {}) => {
  IVM_INSTANCE || (IVM_INSTANCE = e, setIsolateContext(t));
}, SHOULD_MENTION_INITIALIZE_SCRIPT = SDK_NAME === "@builder.io/sdk-react-nextjs" || SDK_NAME === "@builder.io/sdk-react" || SDK_NAME === "@builder.io/sdk-qwik" || SDK_NAME === "@builder.io/sdk-vue", getIvm = () => {
  try {
    if (IVM_INSTANCE)
      return IVM_INSTANCE;
    const t = safeDynamicRequire("isolated-vm");
    if (t)
      return t;
  } catch (t) {
    logger.error("isolated-vm import error.", t);
  }
  const e = `${MSG_PREFIX}could not import \`isolated-vm\` module for safe script execution on a Node server.
    
    SOLUTION: In a server-only execution path within your application, do one of the following:
  
    ${SHOULD_MENTION_INITIALIZE_SCRIPT ? `- import and call \`initializeNodeRuntime()\` from "${SDK_NAME}/node/init".` : ""}
    - add the following import: \`await import('isolated-vm')\`.

    For more information, visit https://builder.io/c/docs/integration-tips#enabling-data-bindings-in-node-environments`;
  throw new Error(e);
};
function setIsolateContext(e = {
  memoryLimit: 128
}) {
  if (IVM_CONTEXT)
    return IVM_CONTEXT;
  const t = getIvm(), n = new t.Isolate(e).createContextSync(), r = n.global;
  return r.setSync("global", r.derefInto()), r.setSync("log", function(...o) {
    console.log(...o);
  }), r.setSync(INJECTED_IVM_GLOBAL, t), IVM_CONTEXT = n, n;
}
const getIsolateContext = () => setIsolateContext(), runInNode = ({
  code: e,
  builder: t,
  context: s,
  event: n,
  localState: r,
  rootSetState: o,
  rootState: i
}) => {
  const I = getIvm(), _ = fastClone({
    ...i,
    ...r
  }), l = getFunctionArguments({
    builder: t,
    context: s,
    event: n,
    state: _
  }), a = getIsolateContext(), E = a.global;
  E.setSync(BUILDER_SET_STATE_NAME, function(c, u) {
    set(i, c, u), o == null || o(i);
  }), l.forEach(([c, u]) => {
    const f = typeof u == "object" ? new I.Reference(
      // workaround: methods with default values for arguments is not being cloned over
      c === "builder" ? {
        ...u,
        getUserAttributes: () => u.getUserAttributes()
      } : u
    ) : null;
    E.setSync(getSyncValName(c), f);
  });
  const d = processCode({
    code: e,
    args: l
  }), y = a.evalClosureSync(d);
  try {
    return JSON.parse(y);
  } catch {
    return y;
  }
};
export {
  fastClone,
  flattenState,
  getBuilderGlobals,
  getFunctionArguments,
  parseCode,
  runInNode,
  set,
  setIvm
};
