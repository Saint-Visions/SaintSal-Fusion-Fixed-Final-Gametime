const b = "react";
function c() {
  return typeof window != "undefined" && typeof document != "undefined";
}
const v = "[Builder.io]: ", f = {
  log: (...t) => console.log(v, ...t),
  error: (...t) => console.error(v, ...t),
  warn: (...t) => console.warn(v, ...t),
  debug: (...t) => console.debug(v, ...t)
}, y = (t) => t != null, at = (t) => {
  if (t === "localhost" || t === "127.0.0.1")
    return t;
  const e = t.split(".");
  return e.length > 2 ? e.slice(1).join(".") : t;
}, O = ({
  name: t,
  canTrack: e
}) => {
  var n;
  try {
    return e ? (n = document.cookie.split("; ").find((r) => r.startsWith(`${t}=`))) == null ? void 0 : n.split("=")[1] : void 0;
  } catch (r) {
    f.warn("[COOKIE] GET error: ", (r == null ? void 0 : r.message) || r);
    return;
  }
}, M = async (t) => O(t), ct = (t) => t.map(([e, n]) => n ? `${e}=${n}` : e).filter(y).join("; "), ut = [["secure", ""], ["SameSite", "None"]], lt = ({
  name: t,
  value: e,
  expires: n
}) => {
  const s = (c() ? location.protocol === "https:" : !0) ? ut : [[]], o = n ? [["expires", n.toUTCString()]] : [[]], i = [[t, e], ...o, ["path", "/"], ["domain", at(window.location.hostname)], ...s];
  return ct(i);
}, T = async ({
  name: t,
  value: e,
  expires: n,
  canTrack: r
}) => {
  try {
    if (!r)
      return;
    const s = lt({
      name: t,
      value: e,
      expires: n
    });
    document.cookie = s;
  } catch (s) {
    f.warn("[COOKIE] SET error: ", (s == null ? void 0 : s.message) || s);
  }
};
const _ = "builder.userAttributes";
function L() {
  let t = !0;
  const e = /* @__PURE__ */ new Set();
  return {
    setUserAttributes(n) {
      if (!c())
        return;
      const r = {
        ...this.getUserAttributes(),
        ...n
      };
      T({
        name: _,
        value: JSON.stringify(r),
        canTrack: t
      }), e.forEach((s) => s(r));
    },
    getUserAttributes() {
      return c() ? JSON.parse(O({
        name: _,
        canTrack: t
      }) || "{}") : {};
    },
    subscribeOnUserAttributesChange(n, {
      fireImmediately: r
    } = {}) {
      return e.add(n), r && n(this.getUserAttributes()), function() {
        e.delete(n);
      };
    },
    setCanTrack(n) {
      t = n;
    }
  };
}
let k;
c() && b === "qwik" ? (window.__BUILDER_USER_ATTRIBUTES_SERVICE__ || (window.__BUILDER_USER_ATTRIBUTES_SERVICE__ = L()), k = window.__BUILDER_USER_ATTRIBUTES_SERVICE__) : k = L();
const W = k, ee = (t) => {
  W.setUserAttributes(t);
}, dt = (t) => {
  const e = {};
  return t.forEach((n, r) => {
    e[r] = n;
  }), e;
}, j = (t) => t instanceof URLSearchParams ? dt(t) : t, $ = (t) => typeof t == "string" ? t : t instanceof URLSearchParams ? t.toString() : new URLSearchParams(t).toString();
function ft() {
  return c() && window.self !== window.top;
}
function ht(t) {
  return ft() && // accessing window.location.search is safe here because `isIframe()` is only `true` if we're in a browser.
  $(t || window.location.search).indexOf("builder.frameEditing=") !== -1;
}
function ne(t) {
  const e = t || (c() ? window.location.search : void 0);
  return e ? $(e).indexOf("builder.preview=") !== -1 : !1;
}
const re = (t) => ({
  type: "builder.registerComponent",
  data: G(t)
}), gt = (t) => {
  const e = t.toString().trim(), n = /^[a-zA-Z0-9_]+\s*=>/i.test(e);
  return `return (${!e.startsWith("function") && !e.startsWith("async") && !e.startsWith("(") && !n ? "function " : ""}${e}).apply(this, arguments)`;
};
function G(t) {
  return JSON.parse(JSON.stringify(t, (e, n) => typeof n == "function" ? gt(n) : n));
}
const N = {};
function se(t, e) {
  t === "plugin" && (e = G(e));
  let n = N[t];
  if (n || (n = N[t] = []), n.push(e), c()) {
    const r = {
      type: "builder.register",
      data: {
        type: t,
        info: e
      }
    };
    try {
      parent.postMessage(r, "*"), parent !== window && window.postMessage(r, "*");
    } catch (s) {
      console.debug("Could not postmessage", s);
    }
  }
}
function oe(t) {
  var e;
  if (c()) {
    const n = JSON.parse(JSON.stringify(t));
    t.action && (n.action = t.action.toString()), (e = window.parent) == null || e.postMessage({
      type: "builder.registerAction",
      data: n
    }, "*");
  }
}
const V = {};
function ie(t) {
  if (c()) {
    Object.assign(V, t);
    const e = {
      type: "builder.settingsChange",
      data: V
    };
    parent.postMessage(e, "*");
  }
}
const D = "builder.", pt = "options.", J = (t) => {
  if (!t)
    return {};
  const e = j(t), n = {};
  return Object.keys(e).forEach((r) => {
    if (r.startsWith(D)) {
      const s = r.replace(D, "").replace(pt, "");
      n[s] = e[r];
    }
  }), n;
}, St = () => {
  if (!c())
    return {};
  const t = new URLSearchParams(window.location.search);
  return J(t);
}, z = "4.2.2", X = () => ({
  "X-Builder-SDK": b,
  "X-Builder-SDK-GEN": "2",
  "X-Builder-SDK-Version": z
});
function yt() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(t) {
    const e = Math.random() * 16 | 0;
    return (t == "x" ? e : e & 3 | 8).toString(16);
  });
}
function H() {
  return yt().replace(/-/g, "");
}
const Q = "builderSessionId", bt = async ({
  canTrack: t
}) => {
  if (!t)
    return;
  const e = await M({
    name: Q,
    canTrack: t
  });
  if (y(e))
    return e;
  {
    const n = mt();
    return wt({
      id: n,
      canTrack: t
    }), n;
  }
}, mt = () => H(), wt = ({
  id: t,
  canTrack: e
}) => T({
  name: Q,
  value: t,
  canTrack: e
}), Y = () => c() && typeof localStorage != "undefined" ? localStorage : void 0, Et = ({
  key: t,
  canTrack: e
}) => {
  var n;
  try {
    return e ? (n = Y()) == null ? void 0 : n.getItem(t) : void 0;
  } catch (r) {
    console.debug("[LocalStorage] GET error: ", r);
    return;
  }
}, It = ({
  key: t,
  canTrack: e,
  value: n
}) => {
  var r;
  try {
    e && ((r = Y()) == null || r.setItem(t, n));
  } catch (s) {
    console.debug("[LocalStorage] SET error: ", s);
  }
}, Z = "builderVisitorId", vt = ({
  canTrack: t
}) => {
  if (!t)
    return;
  const e = Et({
    key: Z,
    canTrack: t
  });
  if (y(e))
    return e;
  {
    const n = At();
    return kt({
      id: n,
      canTrack: t
    }), n;
  }
}, At = () => H(), kt = ({
  id: t,
  canTrack: e
}) => It({
  key: Z,
  value: t,
  canTrack: e
});
function Ut(t) {
  var e;
  typeof process != "undefined" && ((e = process.env) != null && e.DEBUG) && String(process.env.DEBUG) == "true" && f.log(t);
}
const Ot = () => {
  if (c()) {
    const t = new URL(location.href);
    return t.pathname === "" && (t.pathname = "/"), t;
  } else
    return console.warn("Cannot get location for tracking in non-browser environment"), null;
}, Tt = () => typeof navigator == "object" && navigator.userAgent || "", Pt = () => {
  const t = Tt(), e = {
    Android() {
      return t.match(/Android/i);
    },
    BlackBerry() {
      return t.match(/BlackBerry/i);
    },
    iOS() {
      return t.match(/iPhone|iPod/i);
    },
    Opera() {
      return t.match(/Opera Mini/i);
    },
    Windows() {
      return t.match(/IEMobile/i) || t.match(/WPDesktop/i);
    },
    any() {
      return e.Android() || e.BlackBerry() || e.iOS() || e.Opera() || e.Windows() || b === "reactNative";
    }
  }, n = t.match(/Tablet|iPad/i), r = Ot();
  return {
    urlPath: r == null ? void 0 : r.pathname,
    host: (r == null ? void 0 : r.host) || (r == null ? void 0 : r.hostname),
    device: n ? "tablet" : e.any() ? "mobile" : "desktop"
  };
}, Rt = async ({
  canTrack: t
}) => {
  if (!t)
    return {
      visitorId: void 0,
      sessionId: void 0
    };
  const e = await bt({
    canTrack: t
  }), n = vt({
    canTrack: t
  });
  return {
    sessionId: e,
    visitorId: n
  };
}, Ct = async ({
  type: t,
  canTrack: e,
  apiKey: n,
  metadata: r,
  ...s
}) => ({
  type: t,
  data: {
    ...s,
    metadata: {
      url: location.href,
      ...r
    },
    ...await Rt({
      canTrack: e
    }),
    userAttributes: Pt(),
    ownerId: n
  }
});
async function Bt({
  apiHost: t,
  ...e
}) {
  if (!e.apiKey) {
    f.error("Missing API key for track call. Please provide your API key.");
    return;
  }
  if (!e.canTrack || ht() || !(c() || b === "reactNative"))
    return;
  const r = `${t || "https://cdn.builder.io"}/api/v1/track`;
  return Ut(r), fetch(r, {
    method: "POST",
    body: JSON.stringify({
      events: [await Ct(e)]
    }),
    headers: {
      "content-type": "application/json",
      ...X()
    },
    mode: "cors"
  }).catch((s) => {
    console.error("Failed to track: ", s);
  });
}
const ae = (t) => Bt({
  ...t,
  canTrack: !0
}), xt = ["*.beta.builder.io", "beta.builder.io", "builder.io", "localhost", "qa.builder.io"];
function q(t, e) {
  if (!e.origin.startsWith("http") && !e.origin.startsWith("https"))
    return !1;
  const n = new URL(e.origin), r = n.hostname;
  return (t || xt).findIndex((s) => s.startsWith("*.") ? r.endsWith(s.slice(1)) : s === r) > -1;
}
let F = !1;
const _t = (t) => {
  var e, n;
  F || (F = !0, c() && ((e = window.parent) == null || e.postMessage({
    type: "builder.sdkInfo",
    data: {
      target: b,
      version: z,
      supportsPatchUpdates: !1,
      // Supports builder-model="..." attribute which is needed to
      // scope our '+ add block' button styling
      supportsAddBlockScoping: !0,
      supportsCustomBreakpoints: !0,
      modelName: t.modelName,
      apiKey: t.apiKey,
      supportsXSmallBreakpoint: !0,
      blockLevelPersonalization: !0
    }
  }, "*"), (n = window.parent) == null || n.postMessage({
    type: "builder.updateContent",
    data: {
      options: t
    }
  }, "*"), window.addEventListener("message", (r) => {
    var o, i;
    if (!q(t.trustedHosts, r))
      return;
    const {
      data: s
    } = r;
    if (s != null && s.type)
      switch (s.type) {
        case "builder.evaluate": {
          const u = s.data.text, m = s.data.arguments || [], p = s.data.id, w = new Function(u);
          let l, h = null;
          try {
            l = w.apply(null, m);
          } catch (g) {
            h = g;
          }
          h ? (o = window.parent) == null || o.postMessage({
            type: "builder.evaluateError",
            data: {
              id: p,
              error: h.message
            }
          }, "*") : l && typeof l.then == "function" ? l.then((g) => {
            var E;
            (E = window.parent) == null || E.postMessage({
              type: "builder.evaluateResult",
              data: {
                id: p,
                result: g
              }
            }, "*");
          }).catch(console.error) : (i = window.parent) == null || i.postMessage({
            type: "builder.evaluateResult",
            data: {
              result: l,
              id: p
            }
          }, "*");
          break;
        }
      }
  })));
}, Lt = ({
  model: t,
  trustedHosts: e,
  callbacks: n
}) => (r) => {
  if (!q(e, r))
    return;
  const {
    data: s
  } = r;
  if (s)
    switch (s.type) {
      case "builder.configureSdk": {
        n.configureSdk(s.data);
        break;
      }
      case "builder.triggerAnimation": {
        n.animation(s.data);
        break;
      }
      case "builder.resetState": {
        const o = s.data, i = o.model, u = o == null ? void 0 : o.state;
        i === t && u && n.stateUpdate(u);
        break;
      }
      case "builder.contentUpdate": {
        const o = s.data, i = o.key || o.alias || o.entry || o.modelName, u = o.data;
        i === t && n.contentUpdate(u);
        break;
      }
    }
}, ce = ({
  model: t,
  apiKey: e,
  callback: n,
  trustedHosts: r
}) => {
  if (!c)
    return f.warn("`subscribeToEditor` only works in the browser. It currently seems to be running on the server."), () => {
    };
  _t({
    modelName: t,
    apiKey: e
  });
  const s = Lt({
    callbacks: {
      contentUpdate: n,
      animation: () => {
      },
      configureSdk: () => {
      },
      stateUpdate: () => {
      }
    },
    model: t,
    trustedHosts: r
  });
  return window.addEventListener("message", s), () => {
    window.removeEventListener("message", s);
  };
}, Nt = "builder.tests", P = (t) => `${Nt}.${t}`, Vt = ({
  contentId: t
}) => M({
  name: P(t),
  canTrack: !0
}), Dt = ({
  contentId: t
}) => O({
  name: P(t),
  canTrack: !0
}), Ft = ({
  contentId: t,
  value: e
}) => T({
  name: P(t),
  value: e,
  canTrack: !0
}), tt = (t) => y(t.id) && y(t.variations) && Object.keys(t.variations).length > 0, Kt = ({
  id: t,
  variations: e
}) => {
  var s;
  let n = 0;
  const r = Math.random();
  for (const o in e) {
    const i = (s = e[o]) == null ? void 0 : s.testRatio;
    if (n += i, r < n)
      return o;
  }
  return t;
}, et = (t) => {
  const e = Kt(t);
  return Ft({
    contentId: t.id,
    value: e
  }).catch((n) => {
    f.error("could not store A/B test variation: ", n);
  }), e;
}, nt = ({
  item: t,
  testGroupId: e
}) => {
  const n = t.variations[e];
  return e === t.id || // handle edge-case where `testGroupId` points to non-existing variation
  !n ? {
    testVariationId: t.id,
    testVariationName: "Default"
  } : {
    data: n.data,
    testVariationId: n.id,
    testVariationName: n.name || (n.id === t.id ? "Default" : "")
  };
}, ue = ({
  item: t,
  canTrack: e
}) => {
  if (!e)
    return t;
  if (!t)
    return;
  if (!tt(t))
    return t;
  const n = Dt({
    contentId: t.id
  }) || et({
    variations: t.variations,
    id: t.id
  }), r = nt({
    item: t,
    testGroupId: n
  });
  return {
    ...t,
    ...r
  };
}, Mt = async ({
  item: t,
  canTrack: e
}) => {
  if (!e || !tt(t))
    return t;
  const r = await Vt({
    contentId: t.id
  }) || et({
    variations: t.variations,
    id: t.id
  }), s = nt({
    item: t,
    testGroupId: r
  });
  return {
    ...t,
    ...s
  };
}, Wt = (t) => {
  const e = y(t) ? t : !0;
  return W.setCanTrack(e), e;
};
function jt() {
  return typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : globalThis;
}
function $t() {
  const t = jt().fetch;
  if (typeof t == "undefined")
    throw console.warn(`Builder SDK could not find a global fetch function. Make sure you have a polyfill for fetch in your project. 
      For more information, read https://github.com/BuilderIO/this-package-uses-fetch`), new Error("Builder SDK could not find a global `fetch` function");
  return t;
}
const Gt = $t();
function U(t, e = null, n = ".") {
  return Object.keys(t).reduce((r, s) => {
    const o = t[s], i = [e, s].filter(Boolean).join(n);
    return [typeof o == "object", o !== null, !(Array.isArray(o) && o.length === 0)].every(Boolean) ? {
      ...r,
      ...U(o, i, n)
    } : {
      ...r,
      [i]: o
    };
  }, {});
}
function rt(t, e, n = {}) {
  for (const r in t) {
    const s = t[r], o = e ? e + "." + r : r;
    s && typeof s == "object" && !Array.isArray(s) && !Object.keys(s).find((i) => i.startsWith("$")) ? rt(s, o, n) : n[o] = s;
  }
  return n;
}
function Jt(t) {
  const e = {};
  for (const n in t) {
    const r = n.split(".");
    let s = e;
    for (let o = 0; o < r.length; o++) {
      const i = r[o];
      o === r.length - 1 ? s[i] = t[n] : (s[i] = s[i] || {}, s = s[i]);
    }
  }
  return e;
}
const zt = "v3", K = (t) => typeof t == "number" && !isNaN(t) && t >= 0, R = (t) => {
  const {
    limit: e = 30,
    userAttributes: n,
    query: r,
    model: s,
    apiKey: o,
    enrich: i,
    locale: u,
    apiVersion: m = zt,
    fields: p,
    omit: w,
    offset: l,
    cacheSeconds: h,
    staleCacheSeconds: g,
    sort: E,
    includeUnpublished: C,
    apiHost: st
  } = t;
  if (!o)
    throw new Error("Missing API key");
  if (!["v3"].includes(m))
    throw new Error(`Invalid apiVersion: expected 'v3', received '${m}'`);
  const ot = e !== 1, it = st || "https://cdn.builder.io", a = new URL(`${it}/api/${m}/content/${s}`);
  a.searchParams.set("apiKey", o), a.searchParams.set("limit", String(e)), a.searchParams.set("noTraverse", String(ot)), a.searchParams.set("includeRefs", String(!0));
  const A = u || (n == null ? void 0 : n.locale);
  let S = n || {};
  if (A && (a.searchParams.set("locale", A), S = {
    locale: A,
    ...S
  }), i && a.searchParams.set("enrich", String(i)), a.searchParams.set("omit", w != null ? w : "meta.componentsUsed"), p && a.searchParams.set("fields", p), Number.isFinite(l) && l > -1 && a.searchParams.set("offset", String(Math.floor(l))), typeof C == "boolean" && a.searchParams.set("includeUnpublished", String(C)), h && K(h) && a.searchParams.set("cacheSeconds", String(h)), g && K(g) && a.searchParams.set("staleCacheSeconds", String(g)), E) {
    const d = U({
      sort: E
    });
    for (const I in d)
      a.searchParams.set(I, JSON.stringify(d[I]));
  }
  const B = {
    ...St(),
    ...j(t.options || {})
  };
  S = {
    ...S,
    ...Ht(B)
  };
  const x = U(B);
  for (const d in x)
    a.searchParams.set(d, String(x[d]));
  if (Object.keys(S).length > 0 && a.searchParams.set("userAttributes", JSON.stringify(S)), r) {
    const d = rt({
      query: r
    });
    for (const I in d)
      a.searchParams.set(I, JSON.stringify(d[I]));
  }
  return a;
}, Xt = (t) => {
  const e = {};
  for (const n in t)
    n.startsWith("userAttributes.") && (e[n] = t[n], delete t[n]);
  return e;
}, Ht = (t) => {
  if (c() && t.preview === "BUILDER_STUDIO") {
    t["userAttributes.urlPath"] = window.location.pathname, t["userAttributes.host"] = window.location.host;
    const e = Xt(t), {
      userAttributes: n
    } = Jt(e);
    return n;
  }
  return {};
}, Qt = (t) => "results" in t;
async function Yt(t) {
  const e = await te({
    ...t,
    limit: 1
  });
  return e && e[0] || null;
}
const Zt = async (t) => {
  var i, u;
  const e = R(t), n = (i = t.fetch) != null ? i : Gt, r = {
    ...t.fetchOptions,
    headers: {
      ...(u = t.fetchOptions) == null ? void 0 : u.headers,
      ...X()
    }
  };
  return await (await n(e.href, r)).json();
}, qt = async (t, e, n = R(t)) => {
  const r = Wt(t.canTrack);
  if (n.search.includes("preview="), !r || !(c() || b === "reactNative"))
    return e.results;
  try {
    const s = [];
    for (const o of e.results)
      s.push(await Mt({
        item: o,
        canTrack: r
      }));
    e.results = s;
  } catch (s) {
    f.error("Could not process A/B tests. ", s);
  }
  return e.results;
};
async function te(t) {
  const e = R(t), n = await Zt(t);
  if (!Qt(n))
    throw f.error("Error fetching data. ", {
      url: e,
      content: n,
      options: t
    }), n;
  return qt(t, n);
}
const le = async (t) => {
  var r, s, o;
  const e = t.path || ((r = t.url) == null ? void 0 : r.pathname) || ((s = t.userAttributes) == null ? void 0 : s.urlPath), n = {
    ...t,
    apiKey: t.apiKey,
    model: t.model || "page",
    userAttributes: {
      ...t.userAttributes,
      ...e ? {
        urlPath: e
      } : {}
    },
    options: J(t.searchParams || ((o = t.url) == null ? void 0 : o.searchParams) || t.options)
  };
  return {
    apiKey: n.apiKey,
    model: n.model,
    content: await Yt(n)
  };
};
export {
  b as TARGET,
  qt as _processContentResult,
  Bt as _track,
  y as checkIsDefined,
  Lt as createEditorListener,
  re as createRegisterComponentMessage,
  le as fetchBuilderProps,
  te as fetchEntries,
  Yt as fetchOneEntry,
  J as getBuilderSearchParams,
  O as getCookieSync,
  Wt as getDefaultCanTrack,
  Pt as getUserAttributes,
  ue as handleABTestingSync,
  c as isBrowser,
  ht as isEditing,
  ne as isPreviewing,
  Ut as logFetch,
  f as logger,
  se as register,
  oe as registerAction,
  G as serializeIncludingFunctions,
  ee as setClientUserAttributes,
  ie as setEditorSettings,
  _t as setupBrowserForEditing,
  ce as subscribeToEditor,
  ae as track,
  W as userAttributesService
};
